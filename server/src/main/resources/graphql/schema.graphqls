scalar DateTime

type User {
  id: ID!
  username: String!
  userList: [UserListEntry!]!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserListEntry {
  mediaID: Int!
  rated: Boolean!
  rating: Float!
}

union RatingSystem = DiscreteRatingSystem | ContinuousRatingSystem

type DiscreteRatingSystem {
  id: ID!
  name: String!
  ownerId: ID!
  size: Int!
  subRatings: [SubRating!]!
  labels: [String!]!
}

type ContinuousRatingSystem {
  id: ID!
  name: String!
  ownerId: ID!
  size: Int!
  offset: Int!
  subRatings: [SubRating!]!
}

input RatingSystemInput {
  name: String!
  size: Int!
  subRatings: [SubRating!]!
  ratingSystemType: RatingSystemType!
  discreteParam: DiscreteRatingSystemInput
  continuousParam: ContinuousRatingSystemInput
}

enum RatingSystemType {
    DISCRETE
    CONTINUOUS
}

input DiscreteRatingSystemInput {
  labels: [String!]!
}

input ContinuousRatingSystemInput {
  offset: Int!
}

input UserListEntryInput {
  mediaID: Int!
  rated: Boolean!
  rating: Float!
}

input RegisterInput {
  username: String!
  email: String!
  password: String!
}

type RegisterResponse {
  success: Boolean!
}

input LoginInput {
  usernameOrEmail: String!
  password: String!
}

type LoginResponse {
  success: Boolean!
  token: String!
  user: User!
}

input MALOauthInput {
  code: String!
  state: String!
}

type Query {
  me: User
  malLinkOauth: String!
  malLoginOauth: String!
  getRatingSystem(ratingSystemID: String!): RatingSystem
}

type Mutation {
  register(input: RegisterInput!): RegisterResponse
  login(input: LoginInput!): LoginResponse
  malLogin(input: MALOauthInput!): LoginResponse
  logout: Boolean
  malLink(input: MALOauthInput!): Boolean
  addListEntry(input: UserListEntryInput!): Boolean
  updateUserListEntry(input: UserListEntryInput!): UserListEntry
  createRatingSystem(input: RatingSystemInput!): RatingSystem
}
